#!/usr/bin/env python3

from logging import exception
import subprocess
import sys
import os
import syslog as sl
from time import sleep

import yaml

__version__ = "0.4"


def device_exists(d):
    return os.path.exists(d)


def device_already_registered(d):
    device_basename = os.path.basename(d)
    return os.path.exists(f"/sys/class/block/{device_basename}/bcache/")


def get_cache_uuid(c, retry=False):
    cache_basename = os.path.basename(c)
    cache_set_path = f'/sys/class/block/{cache_basename}/bcache/set'
    retries = 1 if retry else 4
    cache_set_found = False
    while (retries < 5):
        if os.path.exists(cache_set_path):
            cache_set_found = True
            break
        sl.syslog(sl.LOG_WARNING, f'Path "{cache_set_path}" does not exist. Retrying in 3s...')
        sleep(3)
        retries += 1
    return os.path.basename(os.readlink(cache_set_path)) if cache_set_found else None


def probe_cache_device(d):
    cmd = ['/lib/udev/bcache-register', d]
    cmd_run = subprocess.run(cmd, capture_output=True)
    if cmd_run.returncode:
        sl.syslog(sl.LOG_WARNING, f'Error while executing \'{" ".join(cmd)}\': {str(cmd_run.stderr)}')

    return cmd_run.returncode


def register_device(d, dtype, cmode):
    if device_exists(d):
        # If dtype is not cache there's a chance that we are trying to re-register
        # the device because it changed size
        if not device_already_registered(d) or (dtype != "cache" and os.getenv('DEVICE_CHANGED')):
            cmd = ['/usr/sbin/make-bcache']
            if dtype == 'cache':
                cmd += ['-C', d]
            else:
                cmd += ['--ioctl', '-B', d] + (['--writeback'] if cmode and str.lower(cmode) == 'wb' else [])
            cmd_run = subprocess.run(cmd, capture_output=True)
            retries = 1
            while (cmd_run.returncode):
                sl.syslog(sl.LOG_WARNING, f'Error while executing \'{" ".join(cmd)}\': {str(cmd_run.stderr)}')
                if (retries > 3):
                    break
                sleep(3)
                cmd_run = subprocess.run(cmd, capture_output=True)
                retries += 1
            return cmd_run.returncode
        else:
            sl.syslog(sl.LOG_INFO, f'Device {d} already registered')
    else:
        sl.syslog(sl.LOG_WARNING, f'Device does not exist: {d}')

    return 0


def attach_backing_to_cache(bd, cset):
    backing_basename = os.path.basename(bd)
    cache_set_path = f'/sys/class/block/{backing_basename}/bcache/cache'
    if os.path.exists(cache_set_path):
        cache_set = os.path.basename(os.readlink(cache_set_path))
        if cache_set == cset:
            sl.syslog(sl.LOG_INFO, f'{bd} already attached to {cset}.')
            return 0
        else:
            sl.syslog(sl.LOG_WARNING, f'{bd} is attached to a different cache: {cache_set} != {cset}. Trying to change it.')

    try:
        with open(f'/sys/class/block/{backing_basename}/bcache/attach', 'w') as f:
            f.write(cset)
        return 0
    except Exception as e:
        sl.syslog(sl.LOG_ERR, f'Unable to attach {bd} to {cset}. Reason: {str(e)}')
        return 1


def attach_backing_and_cache(bds, cd):

    cache_set_uuid = None

    if register_device(cd, "cache", None):
        sl.syslog(sl.LOG_ERR, f'Error while registering cache device {cd}')
    else:
        sl.syslog(sl.LOG_INFO, f'Successfully registered cache device {cd}')

    cache_set_uuid = get_cache_uuid(cd)
    if not cache_set_uuid:
        if probe_cache_device(cd) == 0:
            sl.syslog(sl.LOG_INFO, f'Successfully probed cache device {cd}')

        cache_set_uuid = get_cache_uuid(cd, True)

    for b in bds:
        backing_device = b['device']
        if register_device(backing_device, "backing", b['cache_mode']):
            if not device_already_registered(backing_device) or os.getenv('DEVICE_CHANGED'):
                # Indeed something went wrong with this device
                sl.syslog(sl.LOG_ERR, f'Error while registering backing device {backing_device} ...')
                return 1

        sl.syslog(sl.LOG_INFO, f'Successfully registered backing device {backing_device}')
        sleep(1)  # Wait for the backing device to fully register
        if cache_set_uuid:
            sl.syslog(sl.LOG_INFO, f'Attaching backing device {backing_device} to cache device {cd} with UUID {cache_set_uuid}')
            attach_backing_to_cache(backing_device, cache_set_uuid)

    return 0


try:
    subprocess.call(['/sbin/modprobe', 'bcache'])
except Exception as e:
    sl.syslog(sl.LOG_ERR, f'Unable to probe custom_bcache module. Reason: {str(e)}')
    exit(1)

try:
    with open('/etc/bcache/bcache.conf') as f:
        config = yaml.load(f, Loader=yaml.FullLoader)
except Exception as e:
    sl.syslog(sl.LOG_ERR, f'Unable to load bcache config. Reason: {str(e)}')
    exit(1)

try:
    for cache in config['cache_devices']:
        cache_device = os.path.realpath(cache['device'])
        sys_arg_real_path = os.path.realpath(sys.argv[1])

        # Check if it's a cache device
        if sys_arg_real_path == cache_device:
            sl.syslog(sl.LOG_INFO, f'Managing cache device: {str(sys.argv[1])} (real path: {sys_arg_real_path})')
            attach_backing_and_cache([{**b, 'device': os.path.realpath(b['device'])} for b in cache['backing_devices']], cache_device)
        else:
            # Check if it's a backing device of this cache device
            for backing in cache['backing_devices']:
                backing_device = os.path.realpath(backing['device'])
                if sys_arg_real_path == backing_device:
                    sl.syslog(sl.LOG_INFO, f'Managing backing device: {backing["device"]} (real path: {backing_device})')
                    attach_backing_and_cache([{**backing, 'device': os.path.realpath(backing['device'])}], cache_device)
except Exception as e:
    sl.syslog(sl.LOG_ERR, f'Reason: {str(e)}')
    exit(1)
